namespace threerings.export2 {

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

using MiscUtil.IO;
using MiscUtil.Conversion;

using Ionic.Zlib;

using threerings.trinity.util;

using threerings.export.impl;

/**
 * Imports from the compact binary format generated by {@link BinaryExporter}.
 */
public class BinaryImporter : Importer
{
    /**
     * Creates an importer to read from the specified stream.
     *
     * @param disposeBase whether to Dispose() the underlying stream when we're disposed.
     */
    public BinaryImporter (Stream inStream, bool disposeBase = true)
    {
        _in = new EndianBinaryReader(EndianBitConverter.Big, inStream);
        _disposeBase = disposeBase;
    }

    override
    public object readObject ()
    {
        return readObject<object>();
    }

    override
    public T readObject<T> ()
    {
        if (_in == null) {
            throw new EndOfStreamException("importer already closed");

        } else if (_ctx == null) {
            // verify the preamble
            uint magic = _in.ReadUInt32();
            if (magic != BinaryExporter2.MAGIC_NUMBER) {
                throw new Exception("Invalid magic number [magic=" + magic.ToString("X") + "].");
            }
            byte version = _in.ReadByte();
            switch (version) {
            case BinaryExporter2.VERSION:
                // that's our version!
                break;

            case 0x10: // old export 1.0 mode
                MemoryStream mem = new MemoryStream();
                mem.WriteByte(0xFA);
                mem.WriteByte(0xCE);
                mem.WriteByte(0xAF);
                mem.WriteByte(0x0E);
                mem.WriteByte(0x10);
                // read the rest into the same byte[]...
                const int BUF_SIZE = 4096;
                byte[] buf = new byte[BUF_SIZE];
                while (true) {
                    int count = _in.BaseStream.Read(buf, 0, BUF_SIZE);
                    if (count == 0) {
                        break;
                    }
                    mem.Write(buf, 0, count);
                }
                mem.Position = 0;
                // TODO: dispose base here?
                return new threerings.export.BinaryImporter(mem).readObject<T>();

            default:
                throw new Exception(string.Format("Invalid version [version=%d].", version));
            }

            int flags = Streams.readVarInt(_in.BaseStream);
            bool compressed = (flags & BinaryExporter2.COMPRESSED_FORMAT_FLAG) != 0;

            // the rest of the stream may be compressed
            if (compressed) {
                _in = new EndianBinaryReader(EndianBitConverter.Big,
                        new ZlibStream(_in.BaseStream, CompressionMode.Decompress, !_disposeBase));
            }

            _ctx = new ImportContext(_in);
        }

        return (T)_ctx.readObject(ObjectTypeData.INSTANCE);
    }

    override
    public void Dispose ()
    {
        if (_disposeBase || (_in.BaseStream is ZlibStream)) {
            _in.Dispose();
        }
    }

    /** The stream that we use for reading data. */
    protected EndianBinaryReader _in;

    /** Should we dispose our base stream when we're disposed? */
    protected readonly bool _disposeBase;

    protected ImportContext _ctx;
}
}
